<!DOCTYPE html>
<html><title>My very first toddling steps in ARM assembly language ⁑ Dercuano</title><meta charset="utf-8"></meta><link href="../liabilities/style.css" rel="stylesheet"></link><meta content="width=device-width, initial-scale=1.0" name="viewport"></meta><h1>My very first toddling steps in ARM assembly language</h1><div class="metadata">Kragen Javier Sitaker, 2019-12-10 (updated 2019-12-13)
(46 minutes)</div>
<p>It’s long past time I learned to write a little bit of ARM assembly
and machine code!  So I spent two hours and was able to get
hello-world running, and then a few more hours and learned a bunch of
other things.</p>
<h2>Basic tools</h2>
<p>As it happens, although this laptop is an amd64, it
has cross-compilation and transparent CPU emulation stuff installed,
so this works:</p>
<pre><code>$ cat hello.c
#include &lt;stdio.h&gt;

int main() { printf("hello, world\n"); return 0; }
$ arm-linux-gnueabihf-gcc-5 -static hello.c -o hello.arm
$ ./hello.arm 
hello, world
$
</code></pre>
<p>Specifically I have these Linux Mint packages installed:</p>
<ul>
<li>gcc-5-arm-linux-gnueabihf</li>
<li>gcc-5-arm-linux-gnueabihf-base (its prerequisite)</li>
<li>binutils-arm-linux-gnueabihf</li>
<li>libc6-armhf-cross</li>
<li>qemu-user</li>
<li>qemu-user-binfmt</li>
</ul>
<p>(Warning: much of the following is quoted from glibc, a copyrighted
work licensed under the GNU Lesser General Public License.)</p>
<p>Although I do have libc6-armhf-cross installed, running dynamic
executables does not work.  This makes disassembly kind of a pain:</p>
<pre><code>$ arm-linux-gnueabihf-objdump -d !$
arm-linux-gnueabihf-objdump -d ./a.out

./a.out:     file format elf32-littlearm


Disassembly of section .init:

00010160 &lt;_init&gt;:
   10160:   e92d4008    push    {r3, lr}
   10164:   eb000092    bl  103b4 &lt;call_weak_fn&gt;
   10168:   e8bd8008    pop {r3, pc}

Disassembly of section .iplt:

0001016c &lt;.iplt&gt;:
   1016c:   4778        bx  pc
   1016e:   46c0        nop         ; (mov r8, r8)
   10170:   e28fc600    add ip, pc, #0, 12
   10174:   e28cca68    add ip, ip, #104, 20    ; 0x68000
   10178:   e5bcfe94    ldr pc, [ip, #3732]!    ; 0xe94

Disassembly of section .text:

00010180 &lt;backtrace_and_maps&gt;:
   10180:   2801        cmp r0, #1
   10182:   f340 8084   ble.w   1028e &lt;backtrace_and_maps+0x10e&gt;
   10186:   2900        cmp r1, #0
(97,167 more lines follow)
$
</code></pre>
<h2>My first steps</h2>
<p>We can see that this is Thumb-2 machine code, with some instructions
16-bit and others 32-bit.</p>
<p>Buried in there is the way system calls work on ARM Linux:</p>
<pre><code>00010aa0 &lt;__libc_do_syscall&gt;:
   10aa0:   b580        push    {r7, lr}
   10aa2:   4667        mov r7, ip
   10aa4:   df00        svc 0
   10aa6:   bd80        pop {r7, pc}
</code></pre>
<p>At a guess, r7 selects the system call.</p>
<p>And exit(2):</p>
<pre><code>00020648 &lt;_exit&gt;:
   20648:   b500        push    {lr}
   2064a:   4603        mov r3, r0
   2064c:   f04f 0cf8   mov.w   ip, #248    ; 0xf8
   20650:   f7f0 fa26   bl  10aa0 &lt;__libc_do_syscall&gt;
   20654:   f510 5f80   cmn.w   r0, #4096   ; 0x1000
   20658:   d810        bhi.n   2067c &lt;_exit+0x34&gt;
   2065a:   4618        mov r0, r3
   2065c:   f04f 0c01   mov.w   ip, #1
   20660:   f7f0 fa1e   bl  10aa0 &lt;__libc_do_syscall&gt;
   20664:   f510 5f80   cmn.w   r0, #4096   ; 0x1000
   20668:   d800        bhi.n   2066c &lt;_exit+0x24&gt;
   2066a:   deff        udf #255    ; 0xff
   2066c:   4b07        ldr r3, [pc, #28]   ; (2068c &lt;_exit+0x44&gt;)
   2066e:   ee1d 2f70   mrc 15, 0, r2, cr13, cr0, {3}
   20672:   4240        negs    r0, r0
   20674:   447b        add r3, pc
   20676:   681b        ldr r3, [r3, #0]
   20678:   50d0        str r0, [r2, r3]
   2067a:   deff        udf #255    ; 0xff
   2067c:   4a04        ldr r2, [pc, #16]   ; (20690 &lt;_exit+0x48&gt;)
   2067e:   ee1d 1f70   mrc 15, 0, r1, cr13, cr0, {3}
   20682:   4240        negs    r0, r0
   20684:   447a        add r2, pc
   20686:   6812        ldr r2, [r2, #0]
   20688:   5088        str r0, [r1, r2]
   2068a:   e7e6        b.n 2065a &lt;_exit+0x12&gt;
   2068c:   000589cc    .word   0x000589cc
   20690:   000589bc    .word   0x000589bc
</code></pre>
<p>I’m guessing that this is the actual exiting part:</p>
<pre><code>   2065c:   f04f 0c01   mov.w   ip, #1
   20660:   f7f0 fa1e   bl  10aa0 &lt;__libc_do_syscall&gt;
</code></pre>
<p>So I tried putting this in a file and compiling it:</p>
<pre><code>        ; Attempt to write an ARM assembly program that exits
        ; successfully.
main:   
        mov.w r7, #1
        svc 0
loop:   b.n loop
</code></pre>
<p>But it seems like that is completely the wrong syntax.  I asked GCC
for a listing please:</p>
<pre><code>$ arm-linux-gnueabihf-gcc-5 -static -Wa,-adhlns=hello.lst hello.c
</code></pre>
<p>It obliged:</p>
<pre><code>   1                    .arch armv7-a
   2                    .eabi_attribute 28, 1
   3                    .fpu vfpv3-d16
   4                    .eabi_attribute 20, 1
   5                    .eabi_attribute 21, 1
   6                    .eabi_attribute 23, 3
   7                    .eabi_attribute 24, 1
   8                    .eabi_attribute 25, 1
   9                    .eabi_attribute 26, 2
  10                    .eabi_attribute 30, 6
  11                    .eabi_attribute 34, 1
  12                    .eabi_attribute 18, 4
  13                    .file   "hello.c"
  14                    .section    .rodata
  15                    .align  2
  16                .LC0:
  17 0000 68656C6C      .ascii  "hello, world\000"
  17      6F2C2077 
  17      6F726C64 
  17      00
  18                    .text
  19                    .align  2
  20                    .global main
  21                    .syntax unified
  22                    .thumb
  23                    .thumb_func
  25                main:
  26                    @ args = 0, pretend = 0, frame = 0
  27                    @ frame_needed = 1, uses_anonymous_args = 0
  28 0000 80B5          push    {r7, lr}
  29 0002 00AF          add r7, sp, #0
  30 0004 40F20000      movw    r0, #:lower16:.LC0
  31 0008 C0F20000      movt    r0, #:upper16:.LC0
  32 000c FFF7FEFF      bl  puts
  33 0010 0023          movs    r3, #0
  34 0012 1846          mov r0, r3
  35 0014 80BD          pop {r7, pc}
  37                    .ident  "GCC: (Ubuntu/Linaro 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609"
  38 0016 00BF          .section    .note.GNU-stack,"",%progbits
DEFINED SYMBOLS
                            *ABS*:0000000000000000 hello.c
     /tmp/cc20XqWG.s:15     .rodata:0000000000000000 $d
     /tmp/cc20XqWG.s:16     .rodata:0000000000000000 .LC0
     /tmp/cc20XqWG.s:25     .text:0000000000000000 main
     /tmp/cc20XqWG.s:28     .text:0000000000000000 $t

UNDEFINED SYMBOLS
puts
</code></pre>
<p>Evidently r0 contains the argument for <code>puts</code> and also the return
value for <code>main</code>.</p>
<p>Aping the syntax therein, I tried this:</p>
<pre><code>        @ Attempt to write an ARM assembly program that exits
        @ successfully.
        .arch armv7-a
        .syntax unified
        .thumb
        .globl main
main:   
        mov.w r7, #1
        svc 0
loop:   b.n loop
</code></pre>
<p>That does build successfully; <code>arm-linux-gnueabihf-objdump</code> on the
resulting executable suggests that the requested instructions were
emitted:</p>
<pre><code>(322 lines omitted)
0001049c &lt;main&gt;:
   1049c:   f04f 0701   mov.w   r7, #1
   104a0:   df00        svc 0

000104a2 &lt;loop&gt;:
   104a2:   e7fe        b.n 104a2 &lt;loop&gt;
(87108 lines omitted)
</code></pre>
<p>However, upon execution, the program segfaults.  So I guessed wrong
about <em>something</em> but without a debugger or knowing how to print
things it’s hard to tell what still.</p>
<p>Let’s try building a program that exits successfully with GCC:</p>
<pre><code>$ cat return42.c
int main(int argc, char **argv)
{
  return 42;
}
$ make return42
cc -Wall -Werror -std=gnu99    return42.c   -o return42
$ ./return42 
$ echo $?
42
$ arm-linux-gnueabihf-gcc-5 -static -Wa,-adhlns=return42.lst return42.c
$ cat return42.lst 
...
  21                main:
  22                    @ args = 0, pretend = 0, frame = 8
  23                    @ frame_needed = 1, uses_anonymous_args = 0
  24                    @ link register save eliminated.
  25 0000 80B4          push    {r7}
  26 0002 83B0          sub sp, sp, #12
  27 0004 00AF          add r7, sp, #0
  28 0006 7860          str r0, [r7, #4]
  29 0008 3960          str r1, [r7]
  30 000a 2A23          movs    r3, #42
  31 000c 1846          mov r0, r3
  32 000e 0C37          adds    r7, r7, #12
  33 0010 BD46          mov sp, r7
  34                    @ sp needed
  35 0012 5DF8047B      ldr r7, [sp], #4
  36 0016 7047          bx  lr
...
</code></pre>
<p>Maybe bx is “branch indirect”.  Also maybe I should use some optimization:</p>
<pre><code>  21                main:
  25 0000 2A20          movs    r0, #42
  26 0002 7047          bx  lr
</code></pre>
<p>That’s more like it.  Can I get that to build?</p>
<pre><code>$ cat return42-arm.s
        @ Attempt to write an ARM assembly program that exits
        @ successfully.
        .arch armv7-a
        .syntax unified
        .thumb
        .globl main
main:   
        mov.w r0, #42
        bx lr
loop:   b.n loop
$ arm-linux-gnueabihf-gcc-5 -static return42-arm.s
$ file a.out
a.out: ELF 32-bit LSB executable, ARM, EABI5 version 1 (GNU/Linux), statically linked, for GNU/Linux 3.2.0, BuildID[sha1]=6ddb42d20b6cff668f5c6ded33b82eeda0e3bec3, not stripped
$ ./a.out
qemu: uncaught target signal 4 (Illegal instruction) - core dumped
Illegal instruction
$
</code></pre>
<p>Hmm, that’s not what I was hoping for.  Maybe some of the other
assembly directives are needed to build a runnable executable?</p>
<pre><code>        @ An ARM assembly program that exits successfully.
        .arch armv7-a
        .syntax unified
        .thumb
        .thumb_func
        .globl main
main:   
        mov.w r0, #42
        bx lr
</code></pre>
<p>It turned out to be .thumb_func.  The Gas manual explains, “This
directive specifies that the following symbol is the name of a Thumb
encoded function.  This information is necessary in order to allow the
assembler and linker to generate correct code for interworking [sic]
between Arm and Thumb instructions and should be used even if
interworking is not going to be performed. The presence of this
directive also implies ‘.thumb’.  This directive is not necessary when
generating EABI objects.  On these targets the encoding is implicit
when generating Thumb code.”</p>
<p>(The manual is apparently wrong about it not being necessary when
generating EABI objects.)</p>
<p>A little more perusing of the manual allows me to reduce this to the
following:</p>
<pre><code>        @ An ARM assembly program that exits successfully.
        .arch armv7-a
        .syntax unified
        .thumb_func
        .globl main
main:   mov.w r0, $42
        bx lr
</code></pre>
<p>Adding this line before the return instruction converts the program
into an infinite loop, as expected:</p>
<pre><code>loop:   b.n loop
</code></pre>
<p>This program runs, prints “hello, world” as hoped for, and exits:</p>
<pre><code>        .globl main
main:   push {lr}
        movw r0, #:lower16:hi
        movt r0, #:upper16:hi
        bl puts
        mov r0, $0
        pop {pc}
hi:     .ascii "hello, world\0"
</code></pre>
<p><code>$</code> doesn’t work for the half-symbols.  Note no <code>.thumb_func</code>, and
consequently it generates non-Thumb code!</p>
<pre><code>0001049c &lt;main&gt;:
   1049c:   e52de004    push    {lr}        ; (str lr, [sp, #-4]!)
   104a0:   e30004b4    movw    r0, #1204   ; 0x4b4
   104a4:   e3400001    movt    r0, #1
   104a8:   fa00120e    blx 14ce8 &lt;_IO_puts&gt;
   104ac:   e3a00000    mov r0, #0
   104b0:   e49df004    pop {pc}        ; (ldr pc, [sp], #4)
</code></pre>
<p>Sticking <code>.thumb_func</code> back in there corrects this:</p>
<pre><code>0001049c &lt;main&gt;:
   1049c:   b500        push    {lr}
   1049e:   f240 40ae   movw    r0, #1198   ; 0x4ae
   104a2:   f2c0 0001   movt    r0, #1
   104a6:   f004 fc1f   bl  14ce8 &lt;_IO_puts&gt;
   104aa:   2000        movs    r0, #0
   104ac:   bd00        pop {pc}
</code></pre>
<p>Okay, let’s try something with real computation:</p>
<pre><code>#include &lt;stdlib.h&gt;

int main(int argc, char **argv)
{
  if (atoi(argv[1]) == 37) printf("whoa\n");
  return 0;
}
</code></pre>
<p>This compiles to more or less the following:</p>
<pre><code>  21                main:
  24 0000 08B5          push    {r3, lr}
  25 0002 4868          ldr r0, [r1, #4]
  26 0004 0A22          movs    r2, #10
  27 0006 0021          movs    r1, #0
  28 0008 FFF7FEFF      bl  strtol
  29 000c 2528          cmp r0, #37
  30 000e 05D1          bne .L2
  31 0010 40F20000      movw    r0, #:lower16:.LC0
  32 0014 C0F20000      movt    r0, #:upper16:.LC0
  33 0018 FFF7FEFF      bl  puts
  34                .L2:
  35 001c 0020          movs    r0, #0
  36 001e 08BD          pop {r3, pc}
  38                    .section    .rodata.str1.4,"aMS",%progbits,1
  39                    .align  2
  40                .LC0:
  41 0000 77686F61      .ascii  "whoa\000"
  41      00
</code></pre>
<p>So it looks like it’s calling strtol(argv[1], 0, 10), passing the args
in r0, r1, and r2, and getting the result in r0.  Why it’s saving r3 I
have no idea.  I’m guessing the <code>ldr r0, [r1, #4]</code> syntax is for
indexing 4 bytes off r1 and loading the result into register r0.  The
rest is the same.</p>
<p>Does it use this same register-passing convention for varargs
functions?  Let’s see:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char **argv)
{
  int n = atoi(argv[1]);
  if (n != 37) printf("whoa %d\n", n);
  return 0;
}

  21                main:
  22                    @ args = 0, pretend = 0, frame = 0
  23                    @ frame_needed = 0, uses_anonymous_args = 0
  24 0000 08B5          push    {r3, lr}
  25 0002 4868          ldr r0, [r1, #4]
  26 0004 0A22          movs    r2, #10
  27 0006 0021          movs    r1, #0
  28 0008 FFF7FEFF      bl  strtol
  29 000c 2528          cmp r0, #37
  30 000e 07D0          beq .L2
  31 0010 0246          mov r2, r0
  32 0012 40F20001      movw    r1, #:lower16:.LC0
  33 0016 C0F20001      movt    r1, #:upper16:.LC0
  34 001a 0120          movs    r0, #1
  35 001c FFF7FEFF      bl  __printf_chk
  36                .L2:
  37 0020 0020          movs    r0, #0
  38 0022 08BD          pop {r3, pc}
  40                    .section    .rodata.str1.4,"aMS",%progbits,1
  41                    .align  2
  42                .LC0:
  43 0000 77686F61      .ascii  "whoa %d\012\000"
  43      2025640A 
  43      00
</code></pre>
<p>This looks pretty similar but it seems to be passing the format
argument in r1, the int argument in r2, and the number of arguments in
r0, to a function called <code>__printf_chk</code>.  I can ape this pretty well:</p>
<pre><code>$ cat you-arm.s
        @ Simple ARM assembly program to say "hello, Fred" when run with "Fred"
        .globl main
        .thumb_func
main:   push {r3, lr}
        ldr r2, [r1, #4]    @ argv[1]
        mov r0, $1
        movw r1, #:lower16:hi
        movt r1, #:upper16:hi
        bl __printf_chk
        mov r0, $0
        pop {r3, pc}
hi:     .ascii "hello, %s\n\0"
$ arm-linux-gnueabihf-gcc-5 -static you-arm.s
$ ./a.out Fred
hello, Fred
</code></pre>
<p>So based on the above, I can do the dumb Fibonacci benchmark program:</p>
<pre><code>        @ Simple ARM assembly program to compute dumb Fibonacci
        .thumb_func
fib:    push {r3, lr}
        cmp r0, $0
        beq basecase
        cmp r0, $1
        beq basecase
        push {r0}
        sub r0, r0, $1
        bl fib
        mov r1, r0
        pop {r0}
        push {r1}
        sub r0, r0, $2
        bl fib
        pop {r1}
        add r0, r1, r0
        pop {r3, pc}
basecase:
        mov r0, $1
        pop {r3, pc}


        .globl main
        .thumb_func
main:   push {r3, lr}
        ldr r0, [r1, #4]    @ argv[1]
        mov r1, $0
        mov r2, $10
        bl strtol
        bl fib
        mov r2, r0
        mov r0, $1
        movw r1, #:lower16:hi
        movt r1, #:upper16:hi
        bl __printf_chk
        mov r0, $0
        pop {r3, pc}
hi:     .ascii "fib = %d\n\0"
</code></pre>
<p>This comes out as the following:</p>
<pre><code>0001049c &lt;fib&gt;:
   1049c:   b508        push    {r3, lr}
   1049e:   2800        cmp r0, #0
   104a0:   d00e        beq.n   104c0 &lt;basecase&gt;
   104a2:   2801        cmp r0, #1
   104a4:   d00c        beq.n   104c0 &lt;basecase&gt;
   104a6:   b401        push    {r0}
   104a8:   3801        subs    r0, #1
   104aa:   f7ff fff7   bl  1049c &lt;fib&gt;
   104ae:   1c01        adds    r1, r0, #0
   104b0:   bc01        pop {r0}
   104b2:   b402        push    {r1}
   104b4:   3802        subs    r0, #2
   104b6:   f7ff fff1   bl  1049c &lt;fib&gt;
   104ba:   bc02        pop {r1}
   104bc:   1808        adds    r0, r1, r0
   104be:   bd08        pop {r3, pc}

000104c0 &lt;basecase&gt;:
   104c0:   2001        movs    r0, #1
   104c2:   bd08        pop {r3, pc}

000104c4 &lt;main&gt;:
   104c4:   b508        push    {r3, lr}
   104c6:   6848        ldr r0, [r1, #4]
   104c8:   2100        movs    r1, #0
   104ca:   220a        movs    r2, #10
   104cc:   f003 ff9e   bl  1440c &lt;__strtol&gt;
   104d0:   f7ff ffe4   bl  1049c &lt;fib&gt;
   104d4:   1c02        adds    r2, r0, #0
   104d6:   2001        movs    r0, #1
   104d8:   f240 41e8   movw    r1, #1256   ; 0x4e8
   104dc:   f2c0 0101   movt    r1, #1
   104e0:   f012 fa88   bl  229f4 &lt;___printf_chk&gt;
   104e4:   2000        movs    r0, #0
   104e6:   bd08        pop {r3, pc}
</code></pre>
<p>So I guess I can say that’s the first program I’ve written in ARM
assembly, since the others were mostly just slight modifications of
GCC output.  I’m still cargo-culting the saving of r3, and I probably
should use a less-than comparison rather than two equal-to
comparisons, and I don’t know what order registers get pushed.</p>
<p>It segfaults if you feed it -1, and I think maybe this system is
configured with apport to send the core dumps to Ubuntu or something.</p>
<h2>A minimal -nostdlib program in ARM assembly</h2>
<p>And here’s a program that successfully invokes <code>_exit</code> via the SVC
instruction instead of using the standard library, and thus can be
linked with -nostdlib and doesn’t make a humongous executable:</p>
<pre><code>        @ Attempt to write an ARM assembly program that exits
        @ successfully with -nostdlib.  cf. return42.c.
        .syntax unified
        .thumb_func
        .globl _start
_start: mov r7, #1   @ system call 1: _exit
        mov r0, #42  @ exit return value?
        svc 0
loop:   b.n loop
</code></pre>
<p>This produces a reasonable disassembly:</p>
<pre><code>$ arm-linux-gnueabihf-gcc-5 -static -nostdlib goodbyearm.s
$ ./a.out
$ echo $?
42
$ arm-linux-gnueabihf-objdump -d a.out

a.out:     file format elf32-littlearm


Disassembly of section .text:

00010098 &lt;_start&gt;:
   10098:   f04f 0701   mov.w   r7, #1
   1009c:   f04f 002a   mov.w   r0, #42 ; 0x2a
   100a0:   df00        svc 0

000100a2 &lt;loop&gt;:
   100a2:   e7fe        b.n 100a2 &lt;loop&gt;
$
</code></pre>
<p>So, that took a couple of hours to figure out, but it did eventually
work.</p>
<h2>Machine instructions seen thus far</h2>
<p>Destination register always comes first.</p>
<ul>
<li>svc: supervisor call; in Linux we use svc 0 with the system call
  number in r7.</li>
<li>b.n: branch always</li>
<li>beq, bne: branch if equal or not equal</li>
<li>bx: "branch and exchange" (not necessarily indirect; see below)</li>
<li>bl: branch and link (i.e., call)</li>
<li>push, pop: take sets of registers; can push lr and pop pc.  Not sure
  how order is determined yet.</li>
<li>mov: can load an immediate constant into a register or copy register
  to register</li>
<li>movt: sets upper 16 bits of register to immediate constant</li>
<li>movw: sets register to 16-bit immediate constant (or maybe sets
  lower 16 bits?)</li>
<li>ldr, str: load or store registers to memory, supporting index-offset
  and I think decrement addressing modes</li>
<li>cmp: can compare registers to immediate constants</li>
<li>sub/subs, add/adds: can add or subtract registers, immediate
  constants, or both</li>
<li>nop: nop.</li>
</ul>
<p>Still mysterious: cmn.w, bhi.n, udf, mrc, negs, the whole .w and .n
and “s” suffix thing, and what is this “ip” register?</p>
<p>Hmm, the Gas manual actually explains the "s" suffix: that means to
set the flags.  So presumably "add" just does an addition, while
"adds" does an addition and also sets carry flags and whatnot.</p>
<h2>write(2), and a -nostdlib hello, world</h2>
<p>If we want to get output without stdlib, we need to be able to invoke
the SVC for write(2); looks like maybe that’s the system call with
r7=4:</p>
<pre><code>00021180 &lt;__libc_write&gt;:
   21180:   f8df c04a   ldr.w   ip, [pc, #74]   ; 211ce &lt;__libc_write+0x4e&gt;
   21184:   44fc        add ip, pc
   21186:   f8dc c000   ldr.w   ip, [ip]
   2118a:   f09c 0f00   teq ip, #0
   2118e:   b480        push    {r7}
   21190:   d108        bne.n   211a4 &lt;__libc_write+0x24&gt;
   21192:   2704        movs    r7, #4
   21194:   df00        svc 0
   21196:   bc80        pop {r7}
   21198:   f510 5f80   cmn.w   r0, #4096   ; 0x1000
   2119c:   bf38        it  cc
   2119e:   4770        bxcc    lr
   211a0:   f002 bb4e   b.w 23840 &lt;__syscall_error&gt;
   211a4:   b50f        push    {r0, r1, r2, r3, lr}
   211a6:   f001 f9d9   bl  2255c &lt;__libc_enable_asynccancel&gt;
   211aa:   4684        mov ip, r0
   211ac:   bc0f        pop {r0, r1, r2, r3}
   211ae:   2704        movs    r7, #4
   211b0:   df00        svc 0
   211b2:   4607        mov r7, r0
   211b4:   4660        mov r0, ip
   211b6:   f001 fa15   bl  225e4 &lt;__libc_disable_asynccancel&gt;
   211ba:   4638        mov r0, r7
   211bc:   f85d eb04   ldr.w   lr, [sp], #4
   211c0:   bc80        pop {r7}
   211c2:   f510 5f80   cmn.w   r0, #4096   ; 0x1000
   211c6:   bf38        it  cc
   211c8:   4770        bxcc    lr
   211ca:   f002 bb39   b.w 23840 &lt;__syscall_error&gt;
   211ce:   9d40        .short  0x9d40
   211d0:   bf000005    .word   0xbf000005
</code></pre>
<p>I don’t know what all the extra stuff is in there for but presumably
it covers up some impedance mismatch between the Linux system call and
what the standard library behavior is supposed to be.</p>
<p>On this basis I achieved a stdlibless hello, world:</p>
<pre><code>$ cat hellobarearm.s
        @ Attempt to write an ARM assembly program that hellos
        @ successfully with -nostdlib.  cf. goodbyearm.s
        .syntax unified
        .thumb_func
        .globl _start
_start: mov r7, #4   @ system call 4: write
        mov r0, #0
        movw r1, #:lower16:hello
        movt r1, #:upper16:hello
        mov r2, #(helloend - hello)
        svc 0

        mov r7, #1   @ system call 1: _exit
        mov r0, #0   @ exit return value
        svc 0
hello:  .ascii "hello, world\n"
helloend:       
$ arm-linux-gnueabihf-gcc-5 -static -nostdlib hellobarearm.s
$ ./a.out
hello, world
$ ls -l a.out
-rwxr-xr-x 1 user user 964 Dec 11 02:56 a.out
$ arm-linux-gnueabihf-objdump -d a.out

a.out:     file format elf32-littlearm


Disassembly of section .text:

00010098 &lt;_start&gt;:
   10098:   f04f 0704   mov.w   r7, #4
   1009c:   f04f 0000   mov.w   r0, #0
   100a0:   f240 01b8   movw    r1, #184    ; 0xb8
   100a4:   f2c0 0101   movt    r1, #1
   100a8:   f04f 020d   mov.w   r2, #13
   100ac:   df00        svc 0
   100ae:   f04f 0701   mov.w   r7, #1
   100b2:   f04f 0000   mov.w   r0, #0
   100b6:   df00        svc 0

000100b8 &lt;hello&gt;:
   100b8:   6c6c6568    .word   0x6c6c6568
   100bc:   77202c6f    .word   0x77202c6f
   100c0:   646c726f    .word   0x646c726f
   100c4:   0a              .byte   0x0a

000100c5 &lt;helloend&gt;:
        ...
$
</code></pre>
<p>Note that <code>strip</code> or rather <code>arm-linux-gnueabihf-strip</code> seems to break
objdump’s ability to disassemble the code, but it still runs.  Here’s
a dump of the stripped executable:</p>
<pre><code>$ od -vbAn a.out
 177 105 114 106 001 001 001 000 000 000 000 000 000 000 000 000
 002 000 050 000 001 000 000 000 231 000 001 000 064 000 000 000
 034 001 000 000 000 002 000 005 064 000 040 000 002 000 050 000
 005 000 004 000 001 000 000 000 000 000 000 000 000 000 001 000
 000 000 001 000 306 000 000 000 306 000 000 000 005 000 000 000
 000 000 001 000 004 000 000 000 164 000 000 000 164 000 001 000
 164 000 001 000 044 000 000 000 044 000 000 000 004 000 000 000
 004 000 000 000 004 000 000 000 024 000 000 000 003 000 000 000
 107 116 125 000 005 140 061 140 131 337 041 016 031 220 022 215
 156 115 132 247 261 367 300 226 117 360 004 007 117 360 000 000
 100 362 270 001 300 362 001 001 117 360 015 002 000 337 117 360
 001 007 117 360 000 000 000 337 150 145 154 154 157 054 040 167
 157 162 154 144 012 000 101 036 000 000 000 141 145 141 142 151
 000 001 024 000 000 000 005 067 055 101 000 006 012 007 101 010
 001 011 002 012 004 000 056 163 150 163 164 162 164 141 142 000
 056 156 157 164 145 056 147 156 165 056 142 165 151 154 144 055
 151 144 000 056 164 145 170 164 000 056 101 122 115 056 141 164
 164 162 151 142 165 164 145 163 000 000 000 000 000 000 000 000
 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
 000 000 000 000 013 000 000 000 007 000 000 000 002 000 000 000
 164 000 001 000 164 000 000 000 044 000 000 000 000 000 000 000
 000 000 000 000 004 000 000 000 000 000 000 000 036 000 000 000
 001 000 000 000 006 000 000 000 230 000 001 000 230 000 000 000
 056 000 000 000 000 000 000 000 000 000 000 000 004 000 000 000
 000 000 000 000 044 000 000 000 003 000 000 160 000 000 000 000
 000 000 000 000 306 000 000 000 037 000 000 000 000 000 000 000
 000 000 000 000 001 000 000 000 000 000 000 000 001 000 000 000
 003 000 000 000 000 000 000 000 000 000 000 000 345 000 000 000
 064 000 000 000 000 000 000 000 000 000 000 000 001 000 000 000
 000 000 000 000
</code></pre>
<p>Although, doh, I seem to be writing to fd 0, not fd 1.  QEMU confirms:</p>
<pre><code>$ qemu-arm -strace ./a.out
30784 write(0,0x100b8,13)hello, world
 = 13
30784 exit(0)
</code></pre>
<p>read(2) seems to be syscall 3. open(2) syscall 5, and close(2) syscall
6, and maybe brk() 45 and getpid() 20.</p>
<h2>The ARM-THUMB Procedure Calling Standard</h2>
<p>ARM publishes this document, called the ATPCS for short.  It explains
the use of the registers: r0 and r1 are used for return values; r0 to
r3 are used for arguments and are thus caller-saved; r4 to r11 are
callee-saved general-purpose registers; r11 is also FP, the frame
pointer; r12 is IP, the "intra-procedure-call scratch register"; r13
is SP; r14 is LR, the link register used by the <code>bl</code> instruction; r15
is PC.  The stack grows downwards, and the stack pointer (which must
be 8-byte-aligned when calling a public function) points at the last
thing that was pushed, not the next thing to push.  Interrupt handlers
can execute on your stack, so if you have interrupts you can't depend
on values you've popped staying put.</p>
<p>Newer versions are longer and of poorer quality, though covering more
modern CPU features; fortunately I was able to find an older version,
"SWS ESPC 0002 B-01" (B-01 being the version number), from "24
October, 2000", which is only 37 pages.</p>
<p>Original-THUMB instructions can only access r0 to r7 for most
operands, so you only have 8 general-purpose registers, like the 8088;
more recent ones can access the other 8 registers but I think need
longer instructions.</p>
<p>There are also some special uses of r10 ("SL", "stack limit" in
stack-checked variants), r9 ("SB", "static base" for shared libraries
and other uses of position-independent data), and r7 ("WR",
"Thumb-state Work Register"), but I don't think these affect their use
most of the time --- from the perspective of writing assembly code,
they're mostly just more callee-saved registers, except that I guess
if your assembly code is in a shared library it will use r9.  More
recent versions of the ATPCS eliminate SL and WR and give r9 an
additional role, TR, the "thread register", for TLS I guess.</p>
<p>I think the definition of "IP" means that the dynamic linker is free
to clobber r12 when it's doing lazy dynamic linking, so the callee may
see random crap in r12 if it just got loaded.  This also means it's
caller-saved.</p>
<p>So, in summary, r4-r11 and SP (r13) are callee-saved, and everything
else is caller-saved.  (Except that r10 may get horked by
"limit-checking support code".)</p>
<p>Parameter passing is what you'd expect: everything gets widened to 32
bits, except 64-bit values are split into two 32-bit values (not sure
about endianness).  The first four parameters go into r0-r3, and
subsequent parameters are passed on the stack, first argument last.
(So the argument-count passing used by <code>__printf_chk</code> above is
nonstandard, which I guess is why it was calling <code>__printf_chk</code> and
not <code>printf</code>.)  Return values go in r0, r0-r1, r0-r2, or r0-r3, if
they fit, while longer return values are returned "indirectly, in
memory, via an additional address parameter."  Not sure whether that
parameter is passed in by the caller as a ghostly first parameter or
what.</p>
<p>Floating-point parameter passing is different but uses floating-point
registers.</p>
<p>The floating-point story sounds remarkably like the 8086-family story.
The old FPA register set has 8 extended-precision registers (I think
12 bytes instead of the 8087's 10) that can be used as
single-precision, which has recently been replaced by "VFP", "vector
floating point", which has 16 double-precision registers that can be
used as 32 single-precision registers instead.  A difference is that
they are mutually exclusive: while an Atom supports both 80387
instructions and SSE instructions, ARM chips support either FPA or VFP
or neither, not both.</p>
<p>The assembly-language examples use a syntax closely resembling Intel
syntax, with <code>;</code> for comments and no <code>%</code>, but <code>.</code> to mean the current
position:</p>
<pre><code>    MOV   LR, PC     ; VAL(C) = . + 8
    MOV   PC, r4
</code></pre>
<p>GCC and Gas use something like this syntax by default except for the
comments.  The ATPCS sometimes says things like "-4[FP]" in the body
text; it's not clear to me whether this is valid assembly syntax in
ARM's mind, but Gas seems to be writing that as <code>[fp, #-4]</code>.</p>
<p>"BX" is "branch and exchange", not "branch indirect" as I thought; it
uses the LSB of the address to determine whether to use ARM or THUMB
instructions after the jump.  There's a note: "In ARM architecture
version 5T, a load (but not a move) to the PC also restores the
instruction-set state, allowing an inter-working return to be
performed using LDR, LDM, or POP," which I guess means that before
arm5t that wasn't the case.</p>
<h3>Shared libraries and position-independent code</h3>
<p>To get position-independent code, you have to use PC-relative
references to all your read-only data, and you have to access
read-write data by indexing off SB.  This in particular means that no
static data can point to any other static data without dynamic-linker
intervention, even inside the same segment; and read-only data, to be
sharable, can only point to read-write data by indexing off SB.  I
don't know how non-instruction read-only data can point to read-only
data at all.</p>
<p>There is a delightful hack for shared libraries to find their
read-write data segments in their entry trampolines: every shared
library has a "library index" set at load time, and every shared
library read-write data segment starts with has four pointers into a
"process data table" which lists the data segments of the shared
libraries.  So you're supposed to do this, in THUMB code:</p>
<pre><code>    MOV LSB, SB            ; for some "low register" LSB
    LDR LSB, [LSB, #my_segment]  ; 0, 1, 2, or 3
    LDR LSB, [LSB, #my_index]    ; set by the dynamic linker
</code></pre>
<p>Surprisingly, section 5.8 is about Chez-Scheme-style segmented stacks
(called "chunked stacks").  Too bad there's no explicit support for
closures, although maybe the GCC-style trampoline hack is better than
an explicit context pointer in the ABI, which would slow down every
call.  (Although the SB thing is pretty close to being exactly
an explicit context pointer in the ABI...)</p>
<h3>Stack unwinding</h3>
<p>A surprising thing about the ATPCS is that it contains an unwinding
spec to make it possible for zero-overhead exception handlers to
safely unwind the stack, even through shared libraries, restoring all
callee-saved registers just as if the functions unwound had returned
normally.  Even more surprising is that the recommended approach is to
examine the binary code of the functions on the stack to identify
their prologues or epilogues, and then either interpretively undo the
effect of the prologue, or directly execute the epilogue.  This is
very clever, but for it to work, you need to not move the stack
pointer during the body of the function the way my dumb Fibonacci code
above does.  If that requirement is satisfied, though, I think only a
very minimal amount of auxiliary data is required to make the
unwinding work.</p>
<p>The Gas manual leads me to believe that this is not the method
currently used for unwinding, because it demands that you tell it what
registers you're saving with a <code>.save</code> directive.</p>
<h2>A bit more disassembly, exploring instruction set differences, and failing to figure out shared libraries</h2>
<p>I wrote this C program on a different computer and compiled it with
<code>arm-none-eabi-gcc -S -mthumb -O</code>, with no <code>#include</code> files:</p>
<pre><code>int main(int argc, char **argv) {
    printf("%d\n", atoi(argv[1]) &lt;&lt; 3 | atoi(argv[2]));
    return 0;
}
</code></pre>
<p>The assembly code generated inside <code>main</code> looks mostly like this:</p>
<pre><code>main:
        push    {r3, r4, r5, lr}
        mov     r4, r1
        ldr     r0, [r1, #4]
        bl      atoi
        mov     r5, r0
        ldr     r0, [r4, #8]
        bl      atoi
        lsl     r1, r5, #3
        orr     r1, r0
        ldr     r0, .L2
        bl      printf
        mov     r0, #0
        @ sp needed for prologue
        pop     {r3, r4, r5}
        pop     {r1}
        bx      r1
.L3:
        .align  2
.L2:
        .word   .LC0
        .size   main, .-main
        .section        .rodata.str1.4,"aMS",%progbits,1
        .align  2
.LC0:
        .ascii  "%d\012\000"
</code></pre>
<p>The <code>ldr</code> for the <code>atoi</code> arguments confirms that the #4 or #8 is a
byte offset.  The <code>lsl</code> and <code>orr</code> mnemonics were what I was really
looking for, but I'm surprised not to see the left-shift incorporated
into an operand, because I thought ARM supported a left-shift in every
operand or something.</p>
<p>The <code>ldr r0, .L2</code> is presumably because the 32-bit constant address of
the string at .LC0 is hard to fit into an instruction.  The separate
<code>pop</code> for the return address is presumably because if it used <code>r1</code> in
the same <code>pop</code> it would have been popped in the wrong order (because
in the instruction encoding this is surely some kind of bitfield or
something, not a variable-length list of 4-bit register numbers); this
also clarifies that the first thing in the <code>push</code> or <code>pop</code> list is the
one SP points at within the push/pop pair: the last one to be pushed
and the first one to be popped.  But why didn't it just pop it into
<code>pc</code> rather than using two more instructions?  I suspect the answer is
what I saw earlier in the ATPCS: old ARMs needed an explicit BX to
ensure a switch in instruction encoding.</p>
<p>Previously I was compiling for <code>armv7-a</code> (by the default configuration
of my toolchain on the other computer), and I wonder if that resulted
in using the freer-form Thumb-2 instruction format, in which you <em>can</em>
access the high registers.  Indeed, <em>all</em> of these instructions enter
into 16 bits, except for the immediate operands of the call
instructions:</p>
<pre><code>$ arm-none-eabi-objdump -d shl.o

shl.o:     file format elf32-littlearm


Disassembly of section .text:

00000000 &lt;main&gt;:
   0:   b538        push    {r3, r4, r5, lr}
   2:   1c0c        adds    r4, r1, #0
   4:   6848        ldr r0, [r1, #4]
   6:   f7ff fffe   bl  0 &lt;atoi&gt;
   a:   1c05        adds    r5, r0, #0
   c:   68a0        ldr r0, [r4, #8]
   e:   f7ff fffe   bl  0 &lt;atoi&gt;
  12:   00e9        lsls    r1, r5, #3
  14:   4301        orrs    r1, r0
  16:   4803        ldr r0, [pc, #12]   ; (24 &lt;main+0x24&gt;)
  18:   f7ff fffe   bl  0 &lt;printf&gt;
  1c:   2000        movs    r0, #0
  1e:   bc38        pop {r3, r4, r5}
  20:   bc02        pop {r1}
  22:   4708        bx  r1
  24:   00000000    .word   0x00000000
</code></pre>
<p>We can see that the <code>ldr</code> to get the constant has been compiled as a
PC-relative reference, presumably to support position-independent code
--- although I'm not sure how that word is supposed to get the address
of the string in it in a relocatable way?</p>
<p>It's not; if I instead compile with <code>arm-none-eabi-gcc -S -mthumb
-fPIC -O</code>, I get this instead:</p>
<pre><code>        ldr     r0, .L2
.LPIC0:
        add     r0, pc
        bl      printf
...
.L2:
        .word   .LC0-(.LPIC0+4)
        .size   main, .-main
        .section        .rodata.str1.4,"aMS",%progbits,1
        .align  2
.LC0:
        .ascii  "%d\012\000"
</code></pre>
<p>That is, instead of storing the address of the string, it stores the
PC-relative offset from the place where the string's absolute address
gets computed.  The (static) linker can freely relocate the string
because the .LC0 relocation will fix up the word at .L2 when the final
executable or shared library is built.</p>
<p>With a non-Thumb non-PIC compilation <code>arm-none-eabi-gcc -S -O shl.c</code>
the code for main() is instead:</p>
<pre><code>main:
        @ Function supports interworking.
        @ args = 0, pretend = 0, frame = 0
        @ frame_needed = 0, uses_anonymous_args = 0
        stmfd   sp!, {r3, r4, r5, lr}
        mov     r4, r1
        ldr     r0, [r1, #4]
        bl      atoi
        mov     r5, r0
        ldr     r0, [r4, #8]
        bl      atoi
        orr     r1, r0, r5, asl #3
        ldr     r0, .L2
        bl      printf
        mov     r0, #0
        ldmfd   sp!, {r3, r4, r5, lr}
        bx      lr
</code></pre>
<p>(Again, all of this is without <code>#include</code>s; thus the literal calls to
<code>atoi</code> and <code>printf</code>.)</p>
<p>These are 32-bit instructions, and it seems like it's using the
<code>stmfd</code> and <code>ldmfd</code> instructions (rather than <code>push</code> and <code>pop</code>) to
load and store multiple values; presumably the <code>sp!</code> addressing mode
is some kind of magic autoincrement/autodecrement addressing mode.
The fact that <code>sp</code> is an explicit operand makes it sound like r13 is
just another register and its use as the stack pointer was just a
convention, but I don't think that was really true --- I think even
old ARM interrupt handlers used r13 to save the registers of the
thread being interrupted.  (Certainly the ATPCS documents this as a
thing that could happen in 2000.)</p>
<p>Some of the instructions have three operands instead of two, and the
built-in shift I thought I remembered does see to exist here: <code>orr r1,
r0, r5, asl #3</code>.  Also it's worth noticing that these instructions are
missing the <code>s</code> suffix in the disassembly:</p>
<pre><code>$ arm-none-eabi-objdump -d shl.o

shl.o:     file format elf32-littlearm


Disassembly of section .text:

00000000 &lt;main&gt;:
   0:   e92d4038    push    {r3, r4, r5, lr}
   4:   e1a04001    mov r4, r1
   8:   e5910004    ldr r0, [r1, #4]
   c:   ebfffffe    bl  0 &lt;atoi&gt;
  10:   e1a05000    mov r5, r0
  14:   e5940008    ldr r0, [r4, #8]
  18:   ebfffffe    bl  0 &lt;atoi&gt;
  1c:   e1801185    orr r1, r0, r5, lsl #3
  20:   e59f000c    ldr r0, [pc, #12]   ; 34 &lt;main+0x34&gt;
  24:   ebfffffe    bl  0 &lt;printf&gt;
  28:   e3a00000    mov r0, #0
  2c:   e8bd4038    pop {r3, r4, r5, lr}
  30:   e12fff1e    bx  lr
  34:   00000000    .word   0x00000000
</code></pre>
<p>The Thumb assembly generated by GCC didn't have the <code>s</code> suffix on the
instructions either, but the disassembly did; it turns out that Thumb
instructions always update the flags,
except for <code>mov</code> and <code>add</code> instructions with high registers.  Also note that the
disassembly spells <code>stmfd sp!,</code> as <code>push</code>, just like the Thumb
version.</p>
<p>What about position-independent mutable data?  It turns out to use the
same scheme as position-independent immutable data, contrary to what I
had expected from the ATPCS.  I compiled this C module</p>
<pre><code>static int accumulator;

int octal_digit(int digit) {
    accumulator = accumulator &lt;&lt; 3 | digit;
    return accumulator;
}
</code></pre>
<p>with <code>arm-none-eabi-gcc -mthumb -S -O -fPIC</code> and got this remarkable
result:</p>
<pre><code>octal_digit:
        ldr     r3, .L2
.LPIC0:
        add     r3, pc
        ldr     r1, [r3]
        lsl     r2, r1, #3
        orr     r0, r2
        str     r0, [r3]
        @ sp needed for prologue
        bx      lr
.L3:
        .align  2
.L2:
        .word   .LANCHOR0-(.LPIC0+4)
        .size   octal_digit, .-octal_digit
        .bss
        .align  2
        .set    .LANCHOR0,. + 0
        .type   accumulator, %object
        .size   accumulator, 4
accumulator:
        .space  4
</code></pre>
<p>And this disassembly:</p>
<pre><code>00000000 &lt;octal_digit&gt;:
   0:   4b03        ldr r3, [pc, #12]   ; (10 &lt;octal_digit+0x10&gt;)
   2:   447b        add r3, pc
   4:   6819        ldr r1, [r3, #0]
   6:   00ca        lsls    r2, r1, #3
   8:   4310        orrs    r0, r2
   a:   6018        str r0, [r3, #0]
   c:   4770        bx  lr
   e:   46c0        nop         ; (mov r8, r8)
  10:   0000000a    .word   0x0000000a
</code></pre>
<p>So we have .L2 in the code segment, just after the end of the
function, which contains the BSS address of the read-write variable
<code>accumulator</code>, relative to the instruction at .LPIC0.  So first the
program does a PC-relative <code>ldr</code> to fetch that read-only datum, and
then it adds PC to the fetched datum to obtain the address of
.LANCHOR0, which is the part of BSS that holds this file's
zero-initialized static variables.  This doesn't seem like it could
possibly permit sharing the code segment, since the data at .L2 would
need to be modified according to where (that piece of) BSS is
positioned relative to where this code segment is mapped --- it would
need a fixup by the dynamic linker.</p>
<p>This code also shows that the <code>str</code> instruction has its destination
field on the <em>right</em>.</p>
<p>Without the <code>static</code></p>
<pre><code>int accumulator;

int octal_digit(int digit) {
    accumulator = accumulator &lt;&lt; 3 | digit;
    return accumulator;
}
</code></pre>
<p>we get a different piece of code that refers to a global offset table;
it sure isn't the scheme described in the ATPCS:</p>
<pre><code>octal_digit:
        ldr     r3, .L2
.LPIC0:
        add     r3, pc
        ldr     r2, .L2+4
        ldr     r3, [r3, r2]
        ldr     r1, [r3]
        lsl     r2, r1, #3
        orr     r0, r2
        str     r0, [r3]
        @ sp needed for prologue
        bx      lr
.L3:
        .align  2
.L2:
        .word   _GLOBAL_OFFSET_TABLE_-(.LPIC0+4)
        .word   accumulator(GOT)
        .size   octal_digit, .-octal_digit
        .comm   accumulator,4,4
</code></pre>
<p>I mean this still seems to demand that this code be mapped at a fixed
memory location relative to the <code>_GLOBAL_OFFSET_TABLE_</code> if it isn't
going to be fixed up at load time.  So, I don't know.</p>
<p>Even still, it seems like a relatively heavy price to pay for code
segment sharing that instead of accessing a variable by saying</p>
<pre><code>        ldr     r3, [pc, #12]
</code></pre>
<p>you have to say</p>
<pre><code>        ldr     r3, [pc, #12]
        add     r3, pc
        ldr     r2, [pc, #something]
        ldr     r3, [r3, r2]
        ldr     r1, [r3]
</code></pre>
<p>and also have a per-reference offset stored somewhere the static
linker can fix it up; and so I wonder how often it is really worth it.</p>
<h3>Costs of accessing variables allocated statically</h3>
<p>An interesting thing about this way of referring to variables (or that
described in the ATPCS) is that it reverses the traditional costs of
referring to statically and dynamically allocated variables.  From the
1940s through the 1980s, accessing a statically allocated variable was
cheap: it was at a known, constant address in memory, which could be
baked into the instruction; while accessing a variable allocated
dynamically, for example on the stack, required indexing off the stack
pointer or some other kind of base pointer, which itself had some
extra cost to create and maintain.  (Worse, until around 1970, there
were a significant number of computers where an indexed memory access
required self-modifying code, because they didn't have index
registers.)  But in this case we see that accessing two
dynamically-allocated variables can be as simple as <code>lsl r2, r1, #3</code>,
while accessing a single statically-allocated variable requires a
five-instruction watusi.</p>
<p>At first blush this sounds like a straightforward case of
architectural evolution, but it isn't really.  RAM is just a bunch of
registers, after all.  There are only a couple of minor details of the
ARM architecture that contribute to this situation: it has an
efficient encoding for PC-relative addressing (like amd64, unlike
i386); loading from a constant pointer requires three instructions
(movw, movt, ldr) instead of one; and you only have 16 registers you
can address directly, while everything else is much slower, because
CPU speed has zoomed way ahead of RAM speed.</p>
<p>Rather than a change in architecture, though, it's mostly an evolution
of the execution model.  It's just a different way of using the
machine that prioritizes different tradeoffs.  You could totally use a
PDP-10 or 6502 in such a way: mostly reserve the 6502 zero page for
local variables and frame pointers and whatnot rather than global
variables, and index all your "statically allocated" variables off one
of those registers so that separate processes sharing an address space
store their mutable state in separate "segments".  And although the
Cortex-A7 ARM in your cellphone might have gigabytes of RAM and a deep
cache hierarchy, the Cortex-M0 in a small STM32 doesn't see a whole
lot of difference between its speed of accessing CPU registers and
accessing the on-die SRAM, except that it may need to run several
instructions to compute an address into the on-die SRAM.</p>
<h2>Reading other stuff</h2>
<p><a href="http://infocenter.arm.com/help/topic/com.arm.doc.dui0068b/DUI0068.pdf">ARM published an "assembler user guide" in 2001 that explains the
assembly
language</a>
fairly comprehensively (354 pages!).  Its chapter 4 is the ARM
instruction set reference, and chapter 5 is the Thumb instruction set
reference.  It's marked as "superseded" on ARM's unusably bad website,
but without a link (that I could find) to the superseding version.  On
the 15th page, it explains what ARM and Thumb are; on the 16th page,
it describes the register-banking scheme used to separate user and
supervisor (kernel) mode.  It has a wealth of information about the
historical development of the instruction set, including explaining
literal pools and whatnot.</p>
<p>However, this version of the book lacks such crucial features as
32-bit-wide Thumb-2 instructions and if-then-else blocks.</p>
<p><a href="http://www.toves.org/books/arm/">There's a decent but unfinished 15-page tutorial by Carl
Burch</a> under CC-BY-SA; it explains
the -s suffix on instructions, the absence of an integer division
instruction (though not the existence of extensions that have it), the
built-in shift, the <code>umull</code> instruction, the limitations on <code>mov</code>
immediate constants, <code>mvn</code>, {<code>ldr</code>,<code>str</code>}{<code>b</code>,},
{<code>ld</code>,<code>st</code>}<code>m</code>{<code>i</code>,<code>d</code>}{<code>b</code>,<code>a</code>}, all the ALU instructions,
conditional execution, all the condition codes, all the addressing
modes (including examples of scaled-register-offset and
immediate-post-indexed addressing), etc.</p>
<p>Despite this admirable level of comprehensiveness, it's imperfect; it
seems to be unfinished, stopping after explaining the above but before
describing function call and return, and it doesn't cover Thumb at
all.  Also, the "hailstone sequence" example program has a bug in it
in which the <code>ands</code> instruction overwrites the accumulator, preventing
the program from ever working, and at one point it erroneously says
it's jumping to the beginning of an array of doublewords.  And,
unfortunately, the tutorial uses ARM's assembly syntax instead of
Gas's.</p>
<p><a href="https://gumroad.com/l/arm-assembly-cheat-sheet">Azeria Labs wrote an ARM assembly cheat
sheet</a>, though it's
mostly focused on breakins, and they want to charge you for the
full-resolution version; it's associated with a poorly-written
error-filled tutorial with t0tally k00l diagrams.  <a href="https://news.ycombinator.com/item?id=14432994">The discussion of
it in 2017 on the orange
website</a> links to a lot
of better resources.</p>
<p><a href="https://www.coranac.com/tonc/text/asm.htm">https://www.coranac.com/tonc/text/asm.htm</a>?
<a href="http://www.davespace.co.uk/arm/introduction-to-arm/not-trivial.html">http://www.davespace.co.uk/arm/introduction-to-arm/not-trivial.html</a>?</p><script src="../liabilities/addtoc.js"></script><div><h2>Topics</h2><ul><li><a href="../topics/programming.html">Programming</a> (286 notes)
</li><li><a href="../topics/instruction-sets.html">Instruction sets</a> (40 notes)
</li><li><a href="../topics/asm.html">Assembly language</a> (25 notes)
</li></ul></div></html>