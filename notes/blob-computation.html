<!DOCTYPE html>
<html><title>Blob computation ⁑ Dercuano</title><meta charset="utf-8"></meta><link href="../liabilities/style.css" rel="stylesheet"></link><meta content="width=device-width, initial-scale=1.0" name="viewport"></meta><h1>Blob computation</h1><div class="metadata">Kragen Javier Sitaker, 2017-07-19
(2 minutes)</div><p>So I've been thinking a bunch about content-hash-addressed blob stores
and automatic deterministic recomputation.</p>
<p>One highly desirable attribute of such a system is that the result of
a given computation always be the same — like Java’s WORA aspiration,
but for real this time.  That is, running a program whose code has a
given tree hash A on an input dataset that has another given tree hash
B will always and forever produce an output dataset C that is bitwise
identical to any other time and place that it may have been correctly
computed.  This has several benefits:</p>
<ol>
<li>
<p>The program’s output can be safely cached so that, if the same
   result is requested again in the future, it need not be recomputed;
   it is adequate to use the cached result, at least if you trust the
   place it was computed.</p>
</li>
<li>
<p>Malfunctions or security breaches that produce incorrect outputs
   can always be detected, in theory, by rerunning the computation
   elsewhere.</p>
</li>
<li>
<p>The program's output can be safely <em>deleted</em> from the cache, or
   stored on unreliable storage media that may corrupt bits, because
   its integrity can always be checked against the hash, and it can
   always be produced again on demand.</p>
</li>
<li>
<p>In particular, if our definition of “program” includes a primitive
   that allows us to invoke a given compiler on a “source file” in a
   dataset, then run its output, then we can </p>
</li>
</ol>
<p>There are several difficult prerequisites to achieve it:</p>
<ol>
<li>
<p>You need some kind of virtual machine definition to run program
   code on; the simpler the virtual machine definition, the more
   likely any given implementation is to be correct, but excessive
   definitional simplicity may also make it impractically slow or
   difficult to program for.</p>
</li>
<li>
<p>You need to capture all dependencies</p>
</li>
<li>
<p>Any concurrency must be deterministic</p>
</li>
</ol><script src="../liabilities/addtoc.js"></script><div><h2>Topics</h2><ul><li><a href="../topics/programming.html">Programming</a> (286 notes)
</li><li><a href="../topics/program-design.html">Program design</a> (11 notes)
</li><li><a href="../topics/content-addressable.html">Content addressable</a> (8 notes)
</li><li><a href="../topics/dependencies.html">Dependencies</a> (7 notes)
</li><li><a href="../topics/deterministic-computation.html">Deterministic computation</a> (5 notes)
</li><li><a href="../topics/kogluktualuk.html">Kogluktualuk</a> (2 notes)
</li><li><a href="../topics/deterministic-builds.html">Deterministic builds</a> (2 notes)
</li></ul></div></html>