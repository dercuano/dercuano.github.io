<!DOCTYPE html>
<html><title>Intro to algorithms ⁑ Dercuano</title><meta charset="utf-8"></meta><link href="../liabilities/style.css" rel="stylesheet"></link><meta content="width=device-width, initial-scale=1.0" name="viewport"></meta><h1>Intro to algorithms</h1><div class="metadata">Kragen Javier Sitaker, 2016-09-06
(4 minutes)</div><p>If I want my paper-oriented algorithm notation to be useful, one
avenue is to express algorithms that people are interested in in it.
Perhaps introduction-to-algorithms classes would be a good place to
find them.  So here is a summary of some intro-to-algorithms classes,
covering mostly only the algorithms, although in a few cases I’ve also
included the problems because it wasn’t clear which algorithm was
being taught.  I’ve probably missed a lot.</p>
<p><a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-spring-2008/calendar/">http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-spring-2008/calendar/</a>
is an intro-to-algorithms syllabus.  Algorithms it covers:</p>
<ul>
<li>document distance</li>
<li>mergesort</li>
<li>airplane scheduling</li>
<li>binary search trees</li>
<li>balanced binary search trees</li>
<li>avl trees</li>
<li>hashing</li>
<li>hash table doubling</li>
<li>karp-rabin hashing</li>
<li>rolling hashes</li>
<li>open addressing</li>
<li>heaps</li>
<li>heapsort</li>
<li>stable sorting</li>
<li>radix sort</li>
<li>counting sort</li>
<li>bucket sort</li>
<li>graph search</li>
<li>breadth-first search</li>
<li>depth-first search</li>
<li>topological sort</li>
<li>shortest paths</li>
<li>bellman-ford</li>
<li>dijkstra’s algorithm</li>
<li>dynamic programming</li>
<li>memoized fibonacci</li>
<li>longest common subsequnce</li>
<li>text justification</li>
<li>knapsack</li>
<li>maximum-sum subarray</li>
<li>vertex cover</li>
<li>dominating set</li>
<li>integer multiplication</li>
<li>matrix multiplication</li>
<li>strassen’s algorithm</li>
</ul>
<p><a href="http://www.cs.rpi.edu/~goldsd/spring2013-csci2300.php">http://www.cs.rpi.edu/~goldsd/spring2013-csci2300.php</a> is another,
in some sense much less comprehensive.  It covers:</p>
<ul>
<li>graph coloring</li>
<li>depth-first search</li>
<li>breadth-first search</li>
<li>binary search</li>
<li>topological sort</li>
<li>strongly-connected components</li>
<li>shortest paths</li>
<li>bellman-ford</li>
<li>dijkstra’s algorithm</li>
<li>euler tour</li>
<li>heaps</li>
<li>minimum spanning tree</li>
<li>kruskal</li>
<li>prim</li>
<li>dynamic programming</li>
<li>memoized fibonacci</li>
<li>longest increasing subsequence</li>
<li>pascal’s triangle</li>
<li>sierpinski’s triangle</li>
<li>longest path</li>
<li>hamiltonian cycle</li>
<li>traveling salesman</li>
<li>genetic algorithms</li>
<li>satisfiability</li>
</ul>
<p><a href="http://www.cs.rit.edu/~anh/alg_resources.html">http://www.cs.rit.edu/~anh/alg_resources.html</a> is another.
Unfortunately it doesn’t give any significant detail on what is
covered.</p>
<p><a href="http://www.fas.harvard.edu/~libcs124/E124/syllabus.html">http://www.fas.harvard.edu/~libcs124/E124/syllabus.html</a> is another,
with rather nice lecture notes.  It covers:</p>
<ul>
<li>debiasing coin</li>
<li>mediation and duplation</li>
<li>fibonacci by repeatedly squaring matrices</li>
<li>mergesort</li>
<li>depth-first search</li>
<li>breadth-first search</li>
<li>dijkstra’s algorithm</li>
<li>minimum spanning tree</li>
<li>prim</li>
<li>kruskal</li>
<li>union-find with path compression</li>
<li>satisfiability</li>
<li>set cover</li>
<li>huffman coding</li>
<li>longest common subsequnce</li>
<li>shortest paths</li>
<li>all-pairs shortest paths</li>
<li>traveling salesman</li>
<li>matrix multiplication</li>
<li>strassen’s algorithm</li>
<li>dynamic programming</li>
<li>edit distance</li>
<li>hashing</li>
<li>bloom filters</li>
<li>primality testing</li>
<li>linear programming</li>
<li>simplex algorithm</li>
<li>vertex cover</li>
<li>max cut</li>
<li>factoring</li>
<li>suffix trees</li>
<li>one-time pad</li>
<li>euclid’s algorithm</li>
<li>extended euclid’s algorithm</li>
<li>rsa</li>
<li>least common ancestor</li>
<li>range minimum query</li>
<li>network flow</li>
</ul>
<p><a href="http://www.cse.msstate.edu/~swan/teaching/2008-3_CSE-4833-6833_Algs/schedule.htm">http://www.cse.msstate.edu/~swan/teaching/2008-3_CSE-4833-6833_Algs/schedule.htm</a>
is another, far less comprehensive:</p>
<ul>
<li>insertion sort</li>
<li>mergesort</li>
<li>heapsort</li>
<li>quicksort</li>
<li>dynamic programming</li>
<li>minimum spanning tree</li>
<li>shortest paths</li>
</ul>
<p><a href="http://cs.smith.edu/~streinu/Teaching/Courses/252.html">http://cs.smith.edu/~streinu/Teaching/Courses/252.html</a> is another:</p>
<ul>
<li>depth-first search</li>
<li>breadth-first search</li>
<li>connectivity</li>
<li>minimum spanning tree</li>
<li>shortest paths</li>
<li>traveling salesman</li>
<li>longest path</li>
<li>hamiltonian cycle</li>
<li>satisfiability</li>
<li>clique</li>
<li>vertex cover</li>
<li>integer multiplication</li>
</ul>
<p>Finally,
<a href="http://courses.cs.washington.edu/courses/cse421/14su/">http://courses.cs.washington.edu/courses/cse421/14su/</a>
covers:</p>
<ul>
<li>fft</li>
<li>matrix multiplication</li>
<li>strassen’s algorithm</li>
<li>knapsack</li>
<li>edit distance</li>
<li>depth-first search</li>
<li>breadth-first search</li>
<li>strongly-connected components</li>
<li>shortest paths</li>
<li>minimum spanning tree</li>
<li>satisfiability</li>
<li>vertex cover</li>
<li>graph coloring</li>
<li>traveling salesman</li>
<li>huffman coding</li>
<li>connectivity</li>
<li>topological sort</li>
<li>bipartiteness</li>
<li>fewest coins</li>
<li>interval scheduling</li>
<li>dijkstra’s algorithm</li>
<li>mergesort</li>
<li>inversion counting</li>
<li>closest pair of points</li>
<li>integer multiplication</li>
<li>karatsuba</li>
<li>rsa</li>
<li>dynamic programming</li>
<li>memoized fibonacci</li>
<li>dynamic programming fibonacci</li>
<li>dynamic programming string alignment</li>
<li>dynamic programming fewest coins</li>
<li>weighted interval scheduling</li>
<li>rna structure</li>
<li>network flow</li>
</ul>
<p>Here are the items that appear in more than 2 of those lists:</p>
<pre><code>  6 shortest paths
  5 minimum spanning tree
  5 dynamic programming
  5 depth-first search
  5 breadth-first search
  4 vertex cover
  4 traveling salesman
  4 satisfiability
  4 mergesort
  4 dijkstra’s algorithm
  3 topological sort
  3 strassen’s algorithm
  3 memoized fibonacci
  3 matrix multiplication
  3 integer multiplication
</code></pre>
<p>That’s 15 algorithms or problems, which seems like a reasonably short
list of things to cover; some of them are even redundant, like
Strassen’s algorithm to solve matrix multiplication.</p>
<p>It seems sort of bizarre to me that graph algorithms are given such
great prominence in these introductory courses, since they seem, to me
at least, to have relatively little importance in practical day-to-day
programming.  Certainly we work with graphs all the time, and we even
occasionally topologically sort them.  But shortest-path algorithms
and minimum spanning trees almost never occur in my experience (except
in Ethernet switches).  Even dynamic programming is relatively
uncommon, and search needs heuristics most of the time to be useful.</p><script src="../liabilities/addtoc.js"></script><div><h2>Topics</h2><ul><li><a href="../topics/algorithms.html">Algorithms</a> (123 notes)
</li><li><a href="../topics/education.html">Education</a> (8 notes)
</li><li><a href="../topics/surveys.html">Surveys</a> (2 notes)
</li></ul></div></html>